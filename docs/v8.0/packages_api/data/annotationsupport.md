+++
# -----------------------------------------------------------------------
# Do not edit this file. It is automatically generated by API Documenter.
# -----------------------------------------------------------------------
title = "AnnotationSupport"
keywords = ["grafana","documentation","sdk","@grafana/data"]
type = "docs"
disable_edit_link = true
+++

## AnnotationSupport interface

Since Grafana 7.2

This offers a generic approach to annotation processing

<b>Signature</b>

```typescript
export interface AnnotationSupport<TQuery extends DataQuery = DataQuery, TAnno = AnnotationQuery<TQuery>> 
```
<b>Import</b>

```typescript
import { AnnotationSupport } from '@grafana/data';
```
<b>Properties</b>

|  Property | Type | Description |
|  --- | --- | --- |
|  [QueryEditor](#queryeditor-property) | <code>ComponentType&lt;QueryEditorProps&lt;any, TQuery&gt;&gt;</code> | Specify a custom QueryEditor for the annotation page. If not specified, the standard one will be used |

<b>Methods</b>

|  Method | Description |
|  --- | --- |
|  [prepareAnnotation(json)](#prepareannotation-method) | This hook lets you manipulate any existing stored values before running them though the processor. This is particularly helpful when dealing with migrating old formats. ie query as a string vs object |
|  [prepareQuery(anno)](#preparequery-method) | Convert the stored JSON model to a standard datasource query object. This query will be executed in the datasource and the results converted into events. Returning an undefined result will quietly skip query execution |
|  [processEvents(anno, data)](#processevents-method) | When the standard frame &gt; event processing is insufficient, this allows explicit control of the mappings |

### QueryEditor property

Specify a custom QueryEditor for the annotation page. If not specified, the standard one will be used

<b>Signature</b>

```typescript
QueryEditor?: ComponentType<QueryEditorProps<any, TQuery>>;
```

### prepareAnnotation method

This hook lets you manipulate any existing stored values before running them though the processor. This is particularly helpful when dealing with migrating old formats. ie query as a string vs object

<b>Signature</b>

```typescript
prepareAnnotation?(json: any): TAnno;
```
<b>Parameters</b>

|  Parameter | Type | Description |
|  --- | --- | --- |
|  json | <code>any</code> |  |

<b>Returns:</b>

`TAnno`

### prepareQuery method

Convert the stored JSON model to a standard datasource query object. This query will be executed in the datasource and the results converted into events. Returning an undefined result will quietly skip query execution

<b>Signature</b>

```typescript
prepareQuery?(anno: TAnno): TQuery | undefined;
```
<b>Parameters</b>

|  Parameter | Type | Description |
|  --- | --- | --- |
|  anno | <code>TAnno</code> |  |

<b>Returns:</b>

`TQuery | undefined`

### processEvents method

When the standard frame &gt; event processing is insufficient, this allows explicit control of the mappings

<b>Signature</b>

```typescript
processEvents?(anno: TAnno, data: DataFrame[]): Observable<AnnotationEvent[] | undefined>;
```
<b>Parameters</b>

|  Parameter | Type | Description |
|  --- | --- | --- |
|  anno | <code>TAnno</code> |  |
|  data | <code>DataFrame[]</code> |  |

<b>Returns:</b>

`Observable<AnnotationEvent[] | undefined>`

